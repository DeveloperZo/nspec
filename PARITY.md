# nSpec vs Kiro — Spec UI & Pipeline Gap Analysis

> **Scope:** Visual and interactive spec functionality only — creation, navigation, stage rendering, refinement actions, and task execution. Agent execution, hooks, MCP, pricing, and infra are excluded.
> **Assumption:** VS Code extension with GitHub Copilot (Codex) guaranteed installed → `vscode.lm` always available, no API key required.
> **nSpec version:** v0.3.0 — post Milestones 01–08 (Codex Bridge, Prompt Upgrades, Steering & Context, Spec Variants, Vibe-to-Spec, Quality of Life, Chat Participant, Supervised Execution).
> **Parity doc last reviewed:** Implementation reviewed; table and gaps updated to match current extension + CLI. M08 added supervised task execution (vscode.lm tool-calling), task completion detection (heuristic codebase scan), and diff review (VS Code diff editor with Accept/Reject).
> **Sources:** All Kiro claims are cited `[N]`. See [Sources](#sources) at end.

---

## Gap Analysis

| Feature | Kiro | nSpec | Who Leads | Why |
|---|---|---|---|---|
| **Spec creation entry point** | Dedicated "Kiro pane" in sidebar with `+` button under Specs section. Clicking opens a guided chat where Kiro asks: Feature or Bug? Then asks for description. [A] | Two entry points: (1) **Panel** — modal dialog with spec name, description, spec type selector (Feature / Bugfix), workflow toggle (Requirements-first / Design-first), and template picker (5 domain templates) (M04). (2) **CLI** — `nspec init <name> [--type bugfix] [--mode design-first] [--template rest-api]` (M01+M04). No guided pre-generation questions in either path. | Kiro (slight) | Kiro's guided flow captures intent incrementally via chat. nSpec's modal now offers comparable choice (type, workflow, template) but in a form rather than a conversation. The CLI path enables agent-driven spec creation via AGENTS.md (M01). |
| **Spec type variants** | Two types: **Feature Spec** (new capabilities) and **Bugfix Spec** (root cause + fix + regression prevention). Kiro asks which you want at creation time. [A] | Two types (M04): **Feature Spec** (requirements → design → tasks → verify) and **Bugfix Spec** (root-cause → fix-design → regression-tasks → verify). Type selected via panel dropdown or `nspec init <name> --type bugfix`. Additionally, 5 **domain templates** (REST API, Game Feature, ML Experiment, CLI Tool, Library/SDK) scaffold specs with domain-specific prompts, sections, and steering. | Tied | Both tools support feature and bugfix spec types. Kiro's bugfix format uses unchanged-behavior constraints; nSpec's uses a 4-stage root-cause analysis pipeline. nSpec additionally offers domain templates — a category Kiro does not have. |
| **Workflow variants** | Feature Specs offer two entry points: **Requirements-First** (default — behavior first, architecture follows) and **Design-First** (architecture or existing design first, requirements derived from it). Selected at creation; cannot switch after. Also accepts PNG/JPG architecture diagrams as input. [A][B] | Two workflows (M04): **Requirements-First** (default) and **Design-First** — start from design description, generate `design.md`, then optionally backfill `requirements.md` upward via `nspec backfill <name> requirements`. Panel toggle or `nspec init <name> --mode design-first`. No image/diagram import. | Tied | Both tools support requirements-first and design-first workflows. Kiro additionally accepts visual diagrams (PNG/JPG) as design input. nSpec's backfill command explicitly reverse-generates requirements from design — Kiro derives requirements implicitly during the design-first flow. |
| **Multi-turn clarification before generation** | Before generating `requirements.md`, Kiro asks clarifying questions in chat based on your description. The spec is generated after the back-and-forth is complete. [C][D] | Single-shot: `requirements.md` is generated immediately from the modal input with no clarification phase. User refines after the fact via the Refine bar. | Kiro | Kiro's clarification phase catches ambiguity before documents are written. nSpec's single-shot approach is faster but produces lower-fidelity first drafts for complex features. |
| **Requirements format** | User stories in "As a…" format with acceptance criteria written in EARS notation — `WHEN [condition] THE SYSTEM SHALL [behavior]` / `IF [precondition] THEN THE SYSTEM SHALL [behavior]`. Each requirement numbered (`Requirement 1`, `1.1`, etc.). [D][E] | User stories with Given/When/Then acceptance criteria and FR-N numbering (M02). Plain prose, not EARS. | Kiro (slight) | EARS is more formally constrained — it prevents "the system should support X" type vagueness. nSpec's Given/When/Then achieves similar structure with more readable prose, but is not as strictly unambiguous. |
| **Design document content** | `design.md` includes: system architecture, sequence diagrams, data models, component responsibilities, error handling strategy, testing approach. Generated with codebase context. [A] | `design.md` includes architecture overview, component breakdown, data models, API definitions, tech stack, error handling. Generated with workspace context injection (M03 — reads `package.json`, tsconfig, top-level source). No Mermaid/sequence diagrams in default prompt. | Kiro | Kiro includes sequence diagrams by default. nSpec produces prose descriptions of flows but does not emit Mermaid or structured diagram markup by default (can be enforced via OpenSpec `_prompts/design.md` override). |
| **Requirement-to-task traceability** | Each task in `tasks.md` includes `_Requirements: 1.1, 1.2_` linking back to the numbered acceptance criteria. Tasks are generated dependency-ordered so each can execute after the previous. [D][E] | Each task includes `_Requirements: FR-N_` cross-reference (M02). Tasks are phase-ordered, not topologically dependency-sorted. | Tied | Both tools emit requirement cross-references per task. Kiro's dependency-ordering is more precise (each task is executable in sequence), but nSpec's phase ordering is sufficient for human-executed plans. |
| **Stage navigation UI** | Requirements / Design / Tasks switching buttons appear **in the raw Markdown editor pane only**, not in the Markdown preview pane. Known UX limitation — an open GitHub issue requests adding navigation to preview mode. [F] | Dedicated webview panel with Requirements / Design / Tasks / Verify tabs always visible and clickable regardless of rendering mode. | nSpec | nSpec's webview panel gives persistent tab navigation in all states. Kiro's stage buttons disappear when you switch to Markdown preview, forcing a two-pane workaround for document-heavy review. [F] |
| **Stage rendering** | Spec files open as standard VS Code Markdown editor tabs. Users toggle between raw Markdown and the native VS Code Markdown preview. No custom rendered view — diagrams render in preview, checkboxes render as standard GFM. [F] | Custom webview panel renders each stage with: syntax-aware markdown, interactive checkboxes, progress bar, Refine input bar, and stage-specific action buttons. Not a raw markdown view. | nSpec | nSpec's webview provides a purpose-built reading and interaction surface. Kiro relies on VS Code's native Markdown renderer, which loses stage navigation buttons in preview mode. |
| **Stage refinement actions** | **Requirements:** Edit file directly or open a spec chat session and instruct Kiro to update. **Design:** Click **Refine** button on `design.md` — regenerates design and cascades to update tasks. **Tasks:** Click **Update tasks** on `tasks.md` — regenerates tasks to reflect current requirements/design. [B] | **Panel:** Refine bar below each stage — type instruction, press Refine to regenerate that stage. Cascade button regenerates downstream stages. **CLI (M01):** `nspec refine <name> <stage> --feedback "..."` and `nspec cascade <name>` — enables agent-driven refinement loops. | Tied | Both tools support per-stage refinement. Kiro's cascade is implicit (Refine design → auto-updates tasks). nSpec makes cascade explicit (a separate Cascade button) and also exposes refinement via CLI for agent-driven workflows (M01). |
| **Task execution UI** | Per-task **Run** button executes that task via the agent (writes files, runs commands). **Run all tasks** button executes all incomplete required tasks sequentially. Tasks show real-time status updates (in-progress / completed) as the agent works. [A] | **Panel (M08):** Supervised task execution via `vscode.lm` tool-calling with three tools (`writeFile`, `editFile`, `runCommand`). "Run all tasks" executes incomplete tasks sequentially with per-task progress callback. Backend handlers wired for per-task run (`handleRunTaskSupervised`) and run-all (`handleRunAllTasksSupervised`); inline per-task ▶ Run button markup pending. Supports OpenAI, Anthropic, and `vscode.lm` providers. **CLI (M01):** `nspec status` lists specs + task completion; `nspec cascade` runs the full pipeline. **Agent bridge (M01):** AGENTS.md teaches coding agents to read tasks and execute them autonomously. Cancellation support preserves completed tasks. | Tied | Both tools now support supervised task execution with tool-calling. Kiro's agent is fully built-in with inline per-task Run buttons; nSpec's supervised runner uses `vscode.lm` tool-calling with the same accept/reject flow but per-task inline buttons are pending in the webview (backend is wired). Run-all sequential execution with progress is implemented in both. |
| **Task completion detection** | Two methods: (1) Click **Update tasks** on `tasks.md` — Kiro scans the codebase and auto-marks tasks complete if the relevant code already exists. (2) In a spec chat session, ask "Check which tasks are already complete." [B] | **Implemented (M08):** `checkTaskCompletion()` scans the workspace using three heuristics: file existence (searches 3 levels deep), symbol grep (class/function names across .ts/.js/.py/.go/.rs/etc.), and `package.json` dependency check. Each heuristic contributes to a 0–1 score; tasks scoring >0.7 are auto-toggled complete. **Panel:** `handleCheckTask` (single) and `handleCheckAllTasks` (batch) handlers wired; inline ✓ Check button markup pending. **CLI:** `nspec check-tasks <name>` reports ✅ COMPLETE / ⚠️ PARTIAL / ❌ INCOMPLETE with evidence strings. `_progress.json` persists state across regeneration. | Tied | Both tools scan the codebase and auto-mark tasks. Kiro's detection is AI-driven (the agent evaluates code); nSpec's is heuristic-driven (file existence + symbol grep + package deps, scored 0–1). nSpec additionally exposes a CLI command (`check-tasks`) for agent-driven workflows. |
| **Diff review per task** | In **Supervised mode**, the agent presents proposed file changes as a diff before applying them. The developer accepts or rejects each change. In **Autopilot mode**, diffs are shown after execution for review. [C] | **Implemented (M08):** Each tool-call change (`writeFile`, `editFile`) opens a native VS Code diff editor (`vscode.diff`) showing original vs. proposed content. Accept/Reject buttons via `vscode.window.showInformationMessage`. Accepted changes are applied to the workspace; rejected changes are discarded. Shell commands (`runCommand`) require explicit approval; commands matching `nspec.allowedCommands` allow-list are auto-approved. Temp files managed in `.specs/_temp/`. No batch summary dialog after reviewing all diffs. | Tied | Both tools present per-change diffs with accept/reject. Kiro additionally has an Autopilot mode (apply first, review after); nSpec is supervised-only (review before apply). nSpec adds a shell command allow-list for auto-approving safe commands. |
| **Import existing documents** | `#foo-prfaq.md Generate a spec from it` in a spec chat session — Kiro reads the file and generates all three spec files from it. Also accepts PNG/JPG architecture diagrams as input for Design-First workflow. [B] | **CLI:** `nspec import <name> <stage> <file> [--transform]` — copies file into spec stage; `--transform` AI-transforms content into spec format before importing. Panel: no dedicated Import command (user can open in editor or drop file into `.specs/<name>/`; file watcher refreshes). No chat instruction "generate a spec from this file." | Kiro (slight) | Kiro has in-chat import + diagram input. nSpec has CLI import with optional AI transform; panel/chat import flow not implemented. |
| **#spec cross-reference in chat** | Type `#spec` in any chat session to attach all three files of a spec as context. Enables "implement task 2.3 from #spec:user-auth" style instructions. Kiro includes requirements.md, design.md, and tasks.md automatically. [B] | **Partial:** Chat participant detects `spec:name` or `#spec:name` in the prompt and injects full spec (requirements + design + tasks) as context for the LLM. `/context <spec-name>` command outputs spec as markdown. Native `#spec` variable resolver (picker in chat UI) awaits stable VS Code API (`registerChatVariableResolver`). | Tied (partial) | nSpec injects spec context when the user types spec:name or uses /context; Kiro has a dedicated #spec picker. Full parity when VS Code exposes the variable resolver API. |
| **Vibe-to-spec conversion** | In a vibe (conversational) session, say "Generate spec" — Kiro offers to start a spec session and carries the vibe conversation context into the requirements phase. [B] | **Implemented (M06):** Panel command "nSpec: Generate Spec from Conversation" (selection / clipboard / file). Chat participant `/spec <name>` builds transcript from conversation history and runs the same pipeline (vibe context + requirements). CLI: `nspec vibe-to-spec --name <name> [--transcript <file>] [--cascade]` and stdin. | Tied | Both support converting conversation into a spec. Kiro does it in-chat; nSpec does it via panel (3 input sources), chat `/spec`, or CLI with transcript/cascade. |
| **Streaming generation** | Spec content streams into the editor as the model generates it. [C] | Spec content streams into the webview panel as the model generates it. | Tied | Both stream. |
| **Progress tracking** | Checkboxes in `tasks.md` are the sole progress store. Kiro can auto-update checkbox state by scanning the codebase. [A][B] | Two-layer tracking: checkboxes in `tasks.md` + `_progress.json` that persists state independently so checkbox state survives task regeneration. Progress header ("X / N tasks"), percentage, and progress bar rendered in the webview panel. | nSpec | nSpec's `_progress.json` decouples task state from the generated file, so regenerating tasks doesn't wipe completed checkboxes. Kiro has no equivalent — regenerating `tasks.md` resets all checkbox state. |
| **Verification stage** | No dedicated verification stage. Quality relies on: stage-gate review, requirement-to-task cross-references, and codebase scanning to check completion. [A][B] | Dedicated **Verify** stage (Stage 4): FR coverage matrix built deterministically from parsed `_Requirements: FR-N` fields (M02), Given/When/Then compliance checks (M02), cascade drift detection (requirement→design and design→task mapping), gap report (uncovered FRs, underspecified tasks, missing risk coverage), health score 0–100, and recommended task additions to close gaps. | nSpec | Kiro enforces quality through process (gates, agent review). nSpec makes gaps explicit before implementation starts with a deterministic, structured analysis. M02 tightened the verify prompt to parse traceability fields rather than relying on AI inference. |
| **Custom system prompts & steering** | No mechanism to override generation prompts. Output is influenced via steering files (`.kiro/steering/*.md` — persistent context injected into every prompt) and the clarification chat. `setup-steering` command auto-generates `product.md`, `tech.md`, `structure.md` from the project. | Three layers: (1) **Steering files** — `.specs/steering/*.md` scanned and prepended to every generation prompt; `nspec setup-steering` auto-generates `product.md`, `tech.md`, `structure.md` from workspace (M03). (2) **OpenSpec prompts** — per-stage system prompt override via `_prompts/<stage>.md` (per-spec or workspace-wide). Badge in breadcrumb shows when active. (3) **Workspace context** — `package.json`, tsconfig, top-level source auto-injected into design and tasks generation (M03). | nSpec | Both tools now have steering files with auto-generation. nSpec additionally exposes full system prompt override (OpenSpec) which Kiro does not. nSpec's three-layer customization (steering + prompt override + workspace context) gives more control than Kiro's single steering layer. |
| **Spec file format / portability** | Three plain GFM files per spec under `.kiro/specs/<name>/`. Steering files in `.kiro/steering/`. Version-controlled, diffable, shareable across teams via git. [B][A] | Four plain GFM files + `_progress.json` per spec under `.specs/<name>/`. Steering files in `.specs/steering/` (M03). OpenSpec customization in `_prompts/`, `_sections/`, `_role.md` per spec or workspace-wide. Same path convention as Kiro — files are cross-compatible. | Tied | Both use plain markdown with the same folder convention. nSpec adds `verify.md`, `_progress.json`, and the OpenSpec override layers; Kiro-generated specs open in nSpec and vice versa. |

---

## Scorecard

| Who leads | Count | Features |
|---|---|---|
| **Kiro** | 3 | Spec creation wizard (slight), Multi-turn clarification, Import via chat/diagrams (slight) |
| **nSpec** | 6 | Stage navigation UI (persistent tabs), Stage rendering (custom webview), Progress tracking (regeneration-safe), Verification stage (M02-tightened), Custom system prompts + steering (M03), Spec templates gallery (M04) |
| **Tied** | 12 | Requirements format (Given/When/Then vs EARS), Requirement-to-task traceability (M02), Spec type variants (M04), Workflow variants (M04), Stage refinement actions (panel + CLI), Streaming generation, File format/portability, #spec/spec:name context in chat (partial), Vibe-to-spec (panel + chat /spec + CLI), **Task execution UI (M08 — supervised tool-calling)**, **Task completion detection (M08 — heuristic scan)**, **Diff review per task (M08 — VS Code diff editor)** |
| *Not counted* | 1 | Design document content (Kiro — sequence diagrams) |

### What M01–M08 changed

Milestones 01–03 **narrowed** several gaps. M04 **flipped** spec types and workflows to Tied and added templates. M05–M06 **flipped** two more rows. M08 **flipped** three Kiro leads to Tied:

**M08 flips:**
- **Task execution UI** (Kiro → Tied): Supervised task runner with `vscode.lm` tool-calling (`writeFile`, `editFile`, `runCommand`). Supports OpenAI, Anthropic, and vscode.lm providers. Run-all sequential execution with progress and cancellation. Per-task inline ▶ Run button markup pending.
- **Task completion detection** (Kiro → Tied): Heuristic codebase scan (file existence + symbol grep + package.json deps) with 0–1 scoring; auto-toggles tasks >0.7. CLI `nspec check-tasks <name>` reports evidence. Per-task inline ✓ Check button markup pending.
- **Diff review per task** (Kiro → Tied): Native VS Code diff editor (`vscode.diff`) with Accept/Reject per change. Shell command allow-list (`nspec.allowedCommands`). Supervised-only (no autopilot mode).

**M06 flips:**
- **Vibe-to-spec** (Kiro → Tied): Panel command "Generate Spec from Conversation" (selection / clipboard / file), chat `/spec <name>` using conversation history, and CLI `vibe-to-spec` with transcript/stdin and `--cascade`. Vibe context saved for downstream stages.
- **#spec cross-reference** (Kiro → Tied, partial): Chat participant injects spec context when user types `spec:name` or `#spec:name` in the prompt; `/context <spec-name>` command. Native `#spec` variable resolver (picker) still awaits stable VS Code API.

**M04 flips:**
- **Spec type variants** (Kiro → Tied): Feature + Bugfix with 4-stage bugfix pipeline; panel type selector and `--type bugfix` CLI.
- **Workflow variants** (Kiro → Tied): Design-first with `backfill`; panel toggle and `--mode design-first` CLI.
- **Spec templates** (new nSpec lead): 5 domain templates; panel picker and `--template` CLI.

**M01–M03 narrowing:**
- **Requirements format** (Tied): Given/When/Then (M02).
- **Design document** (still Kiro): Workspace context (M03); sequence diagrams gap remains.
- **Custom prompts & steering** (nSpec): M03 steering + OpenSpec + workspace context.
- **Verification** (nSpec): M02 deterministic `_Requirements:` parsing.

**Import:** CLI `nspec import <name> <stage> <file> [--transform]` added; panel/chat import not implemented.

**M08 implementation notes:** Per-task ▶ Run and ✓ Check inline button markup not yet added to webview HTML (backend handlers are fully wired). No batch diff summary dialog after run-all. No autopilot mode (supervised-only). These are minor UX gaps tracked in Remaining Gaps.

**Key structural insight:** M08 closed Kiro's agent runtime advantage — task execution, diff review, and completion detection are now Tied. Kiro's remaining leads are (1) guided spec creation wizard, (2) multi-turn clarification before generation, and (3) import via chat/diagrams. nSpec leads on customizability (3-layer steering + OpenSpec), verification (deterministic Stage 4), progress tracking (regeneration-safe), and rendering (custom webview). The gap is now 3 Kiro vs 6 nSpec vs 12 Tied.

---

## Highest-value gaps to close given VS Code + Codex guaranteed

### Already closed by M01–M06

| Gap | What was built | Milestone |
|---|---|---|
| ~~Stage navigation in preview~~ | Webview panel with persistent tabs | Pre-M01 |
| ~~Structured requirements format~~ | Given/When/Then with FR-N numbering | M02 |
| ~~Requirement-to-task traceability~~ | `_Requirements: FR-N` on every task, parsed by Verify | M02 |
| ~~Codebase-aware design generation~~ | Workspace context injection | M03 |
| ~~Steering / persistent context~~ | `.specs/steering/*.md` + `setup-steering` | M03 |
| ~~CLI for agent consumption~~ | init, generate, verify, cascade, status, refine, vibe-to-spec, import + AGENTS.md | M01 |
| ~~Bugfix spec type~~ | 4-stage bugfix pipeline, panel + `--type bugfix` | M04 |
| ~~Design-first workflow~~ | `backfill`, panel toggle, `--mode design-first` | M04 |
| ~~Spec templates~~ | 5 domain templates, panel picker, `--template` | M04 |
| ~~Vibe-to-spec~~ | Panel "Generate Spec from Conversation" (selection/clipboard/file), chat `/spec <name>`, CLI `vibe-to-spec` with transcript/stdin and `--cascade` | M06 |
| ~~#spec/spec context in chat~~ | Chat participant: `spec:name` / `#spec:name` in prompt injects full spec context; `/context <spec-name>` command | M06/M07 |
| ~~Import (CLI)~~ | `nspec import <name> <stage> <file> [--transform]` with AI transform | Implemented |
| ~~Per-task run (supervised)~~ | `vscode.lm` tool-calling with `writeFile`/`editFile`/`runCommand` tools; supervised execution via `TaskRunner.runTaskSupervised()`; supports OpenAI, Anthropic, vscode.lm providers; run-all sequential with progress + cancellation | M08 |
| ~~Task completion detection~~ | `checkTaskCompletion()` heuristic scan (file existence + symbol grep + package.json deps); 0–1 scoring, auto-toggle >0.7; CLI `nspec check-tasks <name>` with evidence reporting | M08 |
| ~~Diff review per task~~ | Native VS Code diff editor (`vscode.diff`) with Accept/Reject per change; shell command allow-list (`nspec.allowedCommands`); temp files in `.specs/_temp/` | M08 |

### Remaining gaps — next priorities

| Gap | What to build | Effort | Notes |
|---|---|---|---|
| #spec native variable resolver | `vscode.chat.registerChatVariableResolver('spec')` when API is stable so `#spec` appears as picker in chat UI | 1 day | Partial today: spec:name in prompt + /context |
| Multi-turn clarification | `nspec clarify` interactive CLI + AGENTS.md workflow for clarification before generation | 1–2 days | M07 |
| Import via panel/chat | Panel command or chat instruction to "generate spec from this file" (not just CLI) | 1 day | CLI import + --transform done |
| Per-task inline buttons | Add ▶ Run and ✓ Check button markup to webview HTML template; wire to existing `runTask` / `checkTask` message handlers | 1 day | Backend complete (M08), button markup pending |
| Batch diff summary dialog | After reviewing all diffs in a run-all session, show summary of accepted/rejected changes | 1 day | Cosmetic UX improvement |

---

## Sources

| # | Source | URL | Date |
|---|---|---|---|
| [A] | Kiro official docs — Specs overview | https://kiro.dev/docs/specs/ | Updated Feb 18, 2026 |
| [B] | Kiro official docs — Best Practices (FAQ) | https://kiro.dev/docs/specs/best-practices/ | Accessed Feb 2026 |
| [C] | devclass — Hands-on with Kiro | https://devclass.com/2025/07/15/hands-on-with-kiro | July 15, 2025 |
| [D] | DEV Community — Stop Chatting, Start Specifying | https://dev.to/kirodotdev/stop-chatting-start-specifying-spec-driven-design-with-kiro-ide-3b3o | Dec 5, 2025 |
| [E] | Martin Fowler — Understanding Spec-Driven-Development (hands-on review) | https://martinfowler.com/articles/exploring-gen-ai/sdd-3-tools.html | 2025 |
| [F] | Kiro GitHub Issues — #3127 "Show requirements/design/task list buttons when previewing specs" | https://github.com/kirodotdev/Kiro/issues/3127 | Oct 2, 2025 |